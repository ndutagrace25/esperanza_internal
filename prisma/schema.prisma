// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  // Note: url property is valid for Prisma 6 (we're using 6.19.0)
  url      = env("DATABASE_URL")
}

model Role {
  id        String   @id @default(cuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  employees Employee[]

  @@map("roles")
}

model Employee {
  id        String   @id @default(cuid())
  email     String   @unique
  firstName String
  lastName  String
  position  String?
  department String?
  phone     String?
  password  String
  tempPassword String?
  tempPasswordExpiresAt DateTime?
  roleId    String?
  status    EmployeeStatus   @default(active)
  role      Role?    @relation(fields: [roleId], references: [id])
  hireDate  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  systemLogs SystemLog[]
  assignedClients Client[]  // Clients assigned to this employee
  broughtInClients Client[] @relation("EmployeeToClient")
  jobCards JobCard[] @relation("JobCardsCreated")
  expensesSubmitted Expense[] @relation("ExpensesSubmitted")
  expensesApproved  Expense[] @relation("ExpensesApproved")

  @@map("employees")
}

model SystemLog {
  id          String   @id @default(cuid())
  action      String   // CREATE, UPDATE, DELETE, etc.
  entityType  String   // e.g., "Employee", "Role"
  entityId    String   // ID of the entity being acted upon
  performedBy String?  // Employee ID who performed the action
  employee    Employee? @relation(fields: [performedBy], references: [id])
  oldData     String?  // JSON string of data before change (for UPDATE/DELETE)
  newData     String?  // JSON string of data after change (for CREATE/UPDATE)
  metadata    String?  // JSON string for additional info (IP, user agent, etc.)
  createdAt   DateTime @default(now())

  @@index([entityType, entityId])
  @@index([performedBy])
  @@index([createdAt])
  @@map("system_logs")
}

enum EmployeeStatus {
  active
  on_leave
  terminated
}

model Client {
  id              String        @id @default(cuid())
  companyName     String
  contactPerson   String?       // Primary contact person name
  email           String?       // Primary email
  phone           String?       // Primary phone
  alternatePhone  String?       // Alternate phone number
  address         String?       // Physical address
  city            String?
  state           String?
  country         String?
  postalCode      String?
  website         String?       // Company website
  taxId           String?       // Tax ID or VAT number
  status          ClientStatus  @default(active)
  notes           String?       // Additional notes about the client
  broughtInById   String?       // Employee who brought in the client
  broughtInBy      Employee?     @relation("EmployeeToClient", fields: [broughtInById], references: [id])
  assignedToId    String?       // Employee assigned to manage this client
  assignedTo      Employee?     @relation(fields: [assignedToId], references: [id])
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  jobCards        JobCard[]
  sales           Sale[]

  @@map("clients")
  @@index([status])
  @@index([assignedToId])
  @@index([email])
}

enum ClientStatus {
  active
  inactive
  archived
}

model ProductCategory {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  status      ProductCategoryStatus @default(active)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  products    Product[]

  @@map("product_categories")
  @@index([status])
}

enum ProductCategoryStatus {
  active
  inactive
  archived
}

model Product {
  id              String            @id @default(cuid())
  name            String
  description     String?
  sku             String?           @unique // Stock Keeping Unit
  barcode         String?           @unique // Barcode/EAN
  categoryId      String?
  category        ProductCategory?  @relation(fields: [categoryId], references: [id])
  stockQuantity   Int?              // Current stock quantity
  minStockLevel   Int?              // Minimum stock level for reorder alerts
  unit            String?           // Unit of measurement (e.g., "piece", "kg", "liter", "box")
  status          ProductStatus     @default(active)
  imageUrl        String?           // Product image URL
  supplier        String?           // Supplier name
  supplierContact String?           // Supplier contact information
  notes           String?           // Additional notes
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  saleItems       SaleItem[]

  @@map("products")
  @@index([categoryId])
  @@index([status])
  @@index([sku])
  @@index([barcode])
}

enum ProductStatus {
  active
  inactive
  discontinued
  out_of_stock
}

model JobCard {
  id              String            @id @default(cuid())
  jobNumber       String            @unique  // e.g. "JC-2025-001"
  visitDate       DateTime          // main visit date
  clientId        String            // Changed from Int to String to match Client.id
  client          Client            @relation(fields: [clientId], references: [id])

  location        String?           // override client default location if needed
  contactPerson   String?
  purpose         String?           // e.g. "POS Training + Printer Setup" (made optional)

  // Estimated fields
  estimatedDuration Int?            // estimated duration in minutes
  estimatedCost     Decimal?        @db.Decimal(10, 2) // estimated cost

  startTime       DateTime?         // visit start time
  endTime         DateTime?         // visit end time

  workSummary     String?           // overall work done summary (optional, tasks hold details)
  findings        String?           // findings text
  recommendations String?           // recommendations text

  status          JobCardStatus     @default(PENDING_CLIENT_CONFIRMATION)

  // Audit trail timestamps
  completedAt     DateTime?         // when job card was completed
  cancelledAt     DateTime?         // when job card was cancelled

  // Relations
  tasks           JobTask[]
  expenses        JobExpense[]      // Quick field expenses logged during visit
  formalExpenses  Expense[]         // Formal expense claims linked to this job card
  approvals       JobCardApproval[]

  // Which staff created / handled this job card
  supportStaffId  String?           // Changed from Int to String to match Employee.id
  supportStaff    Employee?     @relation("JobCardsCreated", fields: [supportStaffId], references: [id])

  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  @@index([visitDate])
  @@index([clientId])
  @@index([status])
}

/// Individual tasks / activities done during visit
model JobTask {
  id          String     @id @default(cuid())
  jobCardId   String
  jobCard     JobCard    @relation(fields: [jobCardId], references: [id])

  // Optional categorisation fields
  moduleName  String?    // e.g. "POS", "Inventory", "Reservations"
  taskType    String?    // e.g. "Training", "Setup", "Bug Fix", "Configuration"

  description String     // e.g. "Trained staff on POS sales flow"
  startTime   DateTime?
  endTime     DateTime?

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@index([jobCardId])
}

/// Expenses per job card, dynamic by type/category
model JobExpense {
  id              String     @id @default(cuid())
  jobCardId       String
  jobCard         JobCard    @relation(fields: [jobCardId], references: [id])

  // Fully dynamic â€“ you can store any label here e.g. "Transport", "Lunch", "Parking"
  category        String     // free text
  description     String?    // extra details if needed
  amount          Decimal    @db.Decimal(10, 2)
  hasReceipt      Boolean    @default(false)
  receiptUrl      String?    // if you decide to upload receipt image later
  
  // Link to formal expense claim (when submitted for reimbursement)
  formalExpense   Expense?   // One-to-one: this job expense can become a formal expense claim

  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  @@index([jobCardId])
}

/// Flexible approval / signature flow
/// You can store client, support staff, supervisor, finance approvals here
model JobCardApproval {
  id          String             @id @default(cuid())
  jobCardId   String
  jobCard     JobCard            @relation(fields: [jobCardId], references: [id])

  role        ApprovalRole       // e.g. CLIENT, SUPPORT_STAFF, SUPERVISOR, FINANCE
  approverName String?           // e.g. "John", "Grace"
  approverTitle String?          // e.g. "Manager", "Support Engineer"
  comment     String?            // optional note e.g. "Training completed successfully"
  signedAt    DateTime?          // null until actually signed/approved
  signatureType SignatureType?   // e.g. ON_PAPER, DIGITAL

  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  @@index([jobCardId])
  @@index([role])
}

/// Job card lifecycle
enum JobCardStatus {
  DRAFT
  PENDING_CLIENT_CONFIRMATION
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

/// Who is approving
enum ApprovalRole {
  CLIENT
  DIRECTOR
}

/// How the approval was captured (optional, but nice for future)
enum SignatureType {
  ON_PAPER
  DIGITAL
}

/// Sales model - represents a sale transaction to a client
model Sale {
  id              String        @id @default(cuid())
  saleNumber      String        @unique  // e.g. "SALE-2025-001"
  clientId        String
  client          Client        @relation(fields: [clientId], references: [id])
  saleDate        DateTime      @default(now())
  status          SaleStatus    @default(DRAFT)
  totalAmount     Decimal       @db.Decimal(10, 2) // Calculated from items
  agreedMonthlyInstallmentAmount Decimal?  @db.Decimal(10, 2) // Agreed amount the client will pay each month (optional, for payment plans)
  paidAmount      Decimal       @db.Decimal(10, 2) @default(0) // Sum of paid installments; when paidAmount >= totalAmount, treat as completed
  completedAt     DateTime?     // Set when paidAmount >= totalAmount (fully paid)
  notes           String?       // Additional notes about the sale
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  items           SaleItem[]
  installments    SaleInstallment[]

  @@index([clientId])
  @@index([saleDate])
  @@index([status])
  @@map("sales")
}

/// Monthly (or any) payment installments toward a sale. When sum(installments.amount) >= sale.totalAmount, the sale is considered fully paid/completed.
model SaleInstallment {
  id              String        @id @default(cuid())
  saleId          String
  sale            Sale          @relation(fields: [saleId], references: [id], onDelete: Cascade)
  amount          Decimal       @db.Decimal(10, 2) // Payment amount for this installment
  dueDate         DateTime?     // Optional: when this installment is due (for scheduling)
  paidAt          DateTime      @default(now())    // When the client actually paid
  status          InstallmentStatus @default(PAID) // PENDING = scheduled not yet paid; PAID = recorded payment
  notes           String?       // e.g. "January 2025 installment"
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([saleId])
  @@index([status])
  @@map("sale_installments")
}

enum InstallmentStatus {
  PENDING   // Scheduled but not yet paid
  PAID      // Client has paid this installment
}

/// Individual items in a sale
model SaleItem {
  id              String        @id @default(cuid())
  saleId          String
  sale            Sale           @relation(fields: [saleId], references: [id], onDelete: Cascade)
  productId       String
  product         Product        @relation(fields: [productId], references: [id])
  quantity        Int            // Number of units sold
  unitPrice       Decimal        @db.Decimal(10, 2) // Price per unit at time of sale
  totalPrice      Decimal        @db.Decimal(10, 2) // quantity * unitPrice
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@index([saleId])
  @@index([productId])
  @@map("sale_items")
}

/// Sale status enum
enum SaleStatus {
  DRAFT
  PENDING
  COMPLETED
  CANCELLED
}

/// Expense categories for organizing business expenses
model ExpenseCategory {
  id          String                @id @default(cuid())
  name        String                @unique
  description String?
  status      ExpenseCategoryStatus @default(active)
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  expenses    Expense[]

  @@map("expense_categories")
  @@index([status])
}

enum ExpenseCategoryStatus {
  active
  inactive
  archived
}

/// Business expenses tracking
model Expense {
  id              String          @id @default(cuid())
  expenseNumber   String          @unique  // e.g. "EXP-2025-001"
  categoryId      String
  category        ExpenseCategory @relation(fields: [categoryId], references: [id])
  description     String          // What the expense was for
  amount          Decimal         @db.Decimal(10, 2)
  expenseDate     DateTime        // When the expense occurred
  vendor          String?         // Who was paid (supplier, vendor name)
  referenceNumber String?         // Invoice/receipt number
  paymentMethod   PaymentMethod?  // How it was paid
  status          ExpenseStatus   @default(PENDING)
  hasReceipt      Boolean         @default(false)
  receiptUrl      String?         // Receipt image URL
  notes           String?         // Additional notes
  
  // Job Card linkage (for field expenses)
  jobCardId       String?         // Optional link to job card
  jobCard         JobCard?        @relation(fields: [jobCardId], references: [id])
  jobExpenseId    String?         @unique // Optional link to specific JobExpense record
  jobExpense      JobExpense?     @relation(fields: [jobExpenseId], references: [id])
  
  // Workflow tracking
  submittedById   String?         // Employee who submitted the expense
  submittedBy     Employee?       @relation("ExpensesSubmitted", fields: [submittedById], references: [id])
  approvedById    String?         // Employee who approved the expense
  approvedBy      Employee?       @relation("ExpensesApproved", fields: [approvedById], references: [id])
  approvedAt      DateTime?       // When it was approved
  rejectedAt      DateTime?       // When it was rejected
  rejectionReason String?         // Why it was rejected
  
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@map("expenses")
  @@index([categoryId])
  @@index([status])
  @@index([expenseDate])
  @@index([submittedById])
  @@index([jobCardId])
}

enum ExpenseStatus {
  DRAFT
  PENDING      // Awaiting approval
  APPROVED     // Approved but not yet paid
  PAID         // Paid/Reimbursed
  REJECTED     // Rejected
  CANCELLED    // Cancelled
}

enum PaymentMethod {
  CASH
  BANK_TRANSFER
  MPESA
  CHEQUE
  CREDIT_CARD
  DEBIT_CARD
  OTHER
}


